#!/usr/bin/env python2
# Telegram

# SPDX-FileCopyrightText: 2013 Mathias Kettner <mk@mathias-kettner.de>
# SPDX-FileCopyrightText: 2021 Stefan Gehn <stefan+cmk@srcbox.net>
#
# SPDX-License-Identifier: GPL-2.0-only

# Telegram notification based on asciimail notification from check_mk 1.2.6p16.

import os
import re
import sys
import requests


tmpl_host_text = """*Check_MK: $HOSTNAME$ - $EVENT_TXT$*
```
Host:     $HOSTNAME$
Alias:    $HOSTALIAS$
Address:  $HOSTADDRESS$
Event:    $EVENT_TXT$
Output:   $HOSTOUTPUT$

$LONGHOSTOUTPUT$```"""

tmpl_service_text = """*Check_MK: $HOSTNAME$/$SERVICEDESC$ $EVENT_TXT$*
```
Host:     $HOSTNAME$
Alias:    $HOSTALIAS$
Address:  $HOSTADDRESS$
Service:  $SERVICEDESC$
Event:    $EVENT_TXT$
Output:   $SERVICEOUTPUT$

$LONGSERVICEOUTPUT$```"""


def substitute_context(template, context):
    # First replace all known variables
    for varname, value in context.items():
        template = template.replace("$" + varname + "$", value)

    # Remove the rest of the variables and make them empty
    template = re.sub("\\$[A-Z_][A-Z_0-9]*\\$", "", template)
    return template


def construct_message_text(context):
    notification_type = context["NOTIFICATIONTYPE"]
    if notification_type in ["PROBLEM", "RECOVERY"]:
        txt_info = "$PREVIOUS@HARDSHORTSTATE$ -> $@SHORTSTATE$"
    elif notification_type.startswith("FLAP"):
        if "START" in notification_type:
            txt_info = "Started Flapping"
        else:
            txt_info = "Stopped Flapping ($@SHORTSTATE$)"
    elif notification_type.startswith("DOWNTIME"):
        what = notification_type[8:].title()
        txt_info = "Downtime " + what + " ($@SHORTSTATE$)"
    elif notification_type == "ACKNOWLEDGEMENT":
        txt_info = "Acknowledged ($@SHORTSTATE$)"
    elif notification_type == "CUSTOM":
        txt_info = "Custom Notification ($@SHORTSTATE$)"
    else:
        txt_info = notification_type  # Should never happen

    txt_info = substitute_context(
        txt_info.replace("@", context["WHAT"]),
        context
    )

    context["EVENT_TXT"] = txt_info

    if context["WHAT"] == "HOST":
        tmpl_text = tmpl_host_text
    else:
        tmpl_text = tmpl_service_text

    return substitute_context(tmpl_text, context)


def fetch_notification_context():
    context = {}
    for (var, value) in os.environ.items():
        if var.startswith("NOTIFY_"):
            # this assumes that env vars are transported as utf-8, this plugin
            # needs python str objects with utf-8, not unicode objects!
            context[var[7:]] = value
    return context


def send_telegram_message(token, chat_id, text):
    url = "https://api.telegram.org/bot{}/sendMessage".format(token)
    sys.stderr.write(
        "Sending Telegram message: url={}; chat_id={}; text={}\n".format(
            url, chat_id, text
        )
    )

    json = {"chat_id": chat_id, "text": text, "parse_mode": "Markdown"}
    r = requests.post(url=url, json=json)

    if r.status_code != 200:
        sys.stderr.write(
            "Failed to send Telegram message. Status: {}, Response: {}\n".format(
                r.status_code, r.text
            )
        )
        sys.exit(2)


def context_require(context, name, error_message):
    value = context.get(name)
    if not value:  # e.g. empty field in user database
        sys.stdout.write(
            "Failed to send Telegram message. {}\n".format(error_message)
        )
        sys.exit(2)
    return value


def main():
    context = fetch_notification_context()
    token = context_require(
        context, "PARAMETER_1", "missing bot token parameter"
    )
    chat_id = context_require(
        context, "CONTACT_TELEGRAM_CHAT_ID", "chat id missing for contact"
    )
    text = construct_message_text(context)
    send_telegram_message(token, chat_id, text)


if __name__ == "__main__":
    main()
